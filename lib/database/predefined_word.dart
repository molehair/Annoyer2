// A struct for words

import 'dart:convert';

import 'package:flutter/services.dart' show rootBundle;
import 'package:annoyer/database/local_settings.dart';
import 'package:annoyer/log.dart';
import 'package:isar/isar.dart';

import 'database.dart';
import 'word_index.dart';

part 'predefined_word.g.dart';

const String _predefinedWordsFilepath = 'assets/predefined.json';

@Collection()
class PredefinedWord {
  //---------------------------------------------------------------//
  //        instance variables
  //---------------------------------------------------------------//

  /// The key for database
  /// This field should be used for a convenience only.
  /// For example, when passing a Word to another function with its key.
  @Id()
  int? id;

  String name;
  String def;
  List<String> examples;

  //---------------------------------------------------------------//
  //        static variables
  //---------------------------------------------------------------//

  /// Initialized this class?
  static bool _inited = false;

  /// pre-loaded instances
  // static late final List<PredefinedWord> insts;

  /// indexes
  static final WordIndex<int> nameIndex = WordIndex<int>(fullTextMode: true);

  //---------------------------------------------------------------//
  //        exported methods
  //---------------------------------------------------------------//

  PredefinedWord({
    this.id,
    required this.name,
    required this.def,
    required this.examples,
  });

  static Future<void> initialization() async {
    // init only once
    if (_inited) {
      return;
    }

    // load from file
    var input = await rootBundle.loadString(_predefinedWordsFilepath);
    var map = jsonDecode(input);
    int fileVersion = map['version'];
    var wordsMap = map['words'];

    // add words on demand
    int? dbVersion = await LocalSettings.getPredefinedWordsVersion();
    if (dbVersion == null || dbVersion < fileVersion) {
      Log.info('Updating predefined words');

      // clear db
      await deleteAll();

      // extract words
      List<PredefinedWord> words = [];
      for (var wordMap in wordsMap) {
        words.add(PredefinedWord.fromMap(wordMap));
      }

      // write on database
      // indexes will be constructed during this process
      await addAll(words);

      // mark the version
      await LocalSettings.setPredefinedWordsVersion(fileVersion);

      int total = words.length;
      Log.info(
          'Updated to version $fileVersion of the predefined $total words');
    } else {
      // build indexes from the entire dictionary
      var words = await getAll();
      for (var word in words) {
        nameIndex.add(word.name, word.id!);
      }

      int total = words.length;
      Log.info('Found version $fileVersion of the predefined $total words');
    }

    // mark as finished initialization
    _inited = true;
  }

  PredefinedWord.fromMap(Map<String, Object?> map)
      : id = map['id'] as int?,
        name = map['name'] as String,
        def = map['def'] as String,
        examples = List<String>.from(map['examples'] as List);

  Map<String, Object?> toMap() {
    Map<String, Object?> map = {
      'name': name,
      'def': def,
      'examples': examples,
    };
    if (id != null) {
      map['id'] = id!;
    }
    return map;
  }

  PredefinedWord.fromJson(String jsonString)
      : this.fromMap(jsonDecode(jsonString));

  String toJson() {
    return jsonEncode(toMap());
  }

  @override
  String toString() {
    return toMap().toString();
  }

  /// Get an item
  /// The returned instance has the valid key.
  static Future<PredefinedWord?> get(int id) {
    return Database.isar.predefinedWords.get(id);
  }

  /// Get items by ids
  static Future<List<PredefinedWord?>> gets(Iterable<int> ids) {
    return Database.isar.predefinedWords.getAll(ids.toList());
  }

  /// Get all items
  static Future<List<PredefinedWord>> getAll() {
    return Database.isar.predefinedWords.where().findAll();
  }

  /// Add an item
  static Future<void> add(PredefinedWord word) async {
    // empty id so that it will be generated by isar
    word.id = null;

    // add
    await Database.isar.writeTxn((isar) async {
      await isar.predefinedWords.put(word);
    });

    // update indexes
    nameIndex.add(word.name, word.id!);
  }

  /// Add items
  static Future<void> addAll(Iterable<PredefinedWord> words) async {
    // empty ids so that it will be generated by isar
    for (var word in words) {
      word.id = null;
    }

    // add
    await Database.isar.writeTxn((isar) async {
      await Database.isar.predefinedWords.putAll(words.toList());
    });

    // update indexes
    for (var word in words) {
      nameIndex.add(word.name, word.id!);
    }
  }

  /// Save an item associated with id
  static Future<void> put(PredefinedWord word) async {
    assert(word.id != null);
    await Database.isar.writeTxn((isar) async {
      await isar.predefinedWords.put(word);
    });

    // update indexes
    nameIndex.removeByValue(word.id!);
    nameIndex.add(word.name, word.id!);
  }

  /// Delete an item
  static Future<void> delete(int id) async {
    await Database.isar.writeTxn((isar) async {
      await isar.predefinedWords.delete(id);
    });

    // update indexes
    nameIndex.removeByValue(id);
  }

  /// Delete items by [ids]
  static Future<void> deletes(Iterable<int> ids) async {
    await Database.isar.writeTxn((isar) async {
      await isar.predefinedWords.deleteAll(ids.toList());
    });

    // update indexes
    for (int id in ids) {
      nameIndex.removeByValue(id);
    }
  }

  /// Delete all items
  static Future<void> deleteAll() async {
    await Database.isar.writeTxn((isar) async {
      await isar.predefinedWords.where().deleteAll();
    });

    // update indexes
    nameIndex.clear();
  }

  /// RETURN: the number of all items
  static Future<int> count() {
    return Database.isar.predefinedWords.where().count();
  }

  /// Get stream
  static Stream<void> getStream() {
    return Database.isar.predefinedWords.watchLazy();
  }

  //---------------------------------------------------------------//
  //        internal methods
  //---------------------------------------------------------------//
}
