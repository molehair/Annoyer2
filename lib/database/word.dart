// A struct for words

import 'dart:convert';

import 'package:isar/isar.dart';
import 'package:uuid/uuid.dart';

import 'database.dart';
import 'word_index.dart';

part 'word.g.dart';

@Collection()
class Word {
  //---------------------------------------------------------------//
  //        instance variables
  //---------------------------------------------------------------//

  /// The key for database
  /// This field should be used for a convenience only.
  /// For example, when passing a Word to another function with its key.
  @Id()
  int? id;

  String name;
  String def;
  String ex;
  String? mnemonic;
  int level; // >= 1

  // sync related
  String syncId;

  //---------------------------------------------------------------//
  //        static variables
  //---------------------------------------------------------------//

  /// Initialized this class?
  static bool _inited = false;

  /// indexes
  static final WordIndex<int> nameIndex = WordIndex<int>(fullTextMode: true);
  static final WordIndex<int> defIndex = WordIndex<int>();

  //---------------------------------------------------------------//
  //        exported methods
  //---------------------------------------------------------------//

  Word({
    this.id,
    required this.name,
    required this.def,
    required this.ex,
    this.mnemonic,
    this.level = 1,
  }) : syncId = _createRandomSyncId();

  static Future<void> initialization() async {
    // init only once
    if (_inited) {
      return;
    }

    // build indexes from the entire dictionary
    List<Word> words = await getAll();
    for (Word word in words) {
      nameIndex.add(word.name, word.id!);
      defIndex.add(word.def, word.id!);
    }

    // mark as finished initialization
    _inited = true;
  }

  Word.fromMap(Map<String, Object?> map)
      : id = map['id'] as int?,
        name = map['name'] as String,
        def = map['def'] as String,
        ex = map['ex'] as String,
        mnemonic = map['mnemonic'] as String?,
        level = map['level'] as int,
        syncId = map['syncId'] as String;

  Map<String, Object?> toMap() {
    Map<String, Object?> map = {
      'name': name,
      'def': def,
      'ex': ex,
      'level': level,
      'syncId': syncId,
    };
    if (id != null) {
      map['id'] = id!;
    }
    if (mnemonic != null) {
      map['mnemonic'] = mnemonic!;
    }
    return map;
  }

  Word.fromJson(String jsonString) : this.fromMap(jsonDecode(jsonString));

  String toJson() {
    return jsonEncode(toMap());
  }

  @override
  String toString() {
    return toMap().toString();
  }

  /// Get an item
  /// The returned instance has the valid key.
  static Future<Word?> get(int id) {
    return Database.isar.words.get(id);
  }

  /// Get items by ids
  static Future<List<Word?>> gets(Iterable<int> ids) {
    return Database.isar.words.getAll(ids.toList());
  }

  /// Get all items
  static Future<List<Word>> getAll() {
    return Database.isar.words.where().findAll();
  }

  /// Add an item
  static Future<void> add(Word word) async {
    // empty id so that it will be generated by isar
    word.id = null;

    // add
    await Database.isar.writeTxn((isar) async {
      await isar.words.put(word);
    });

    // update indexes
    nameIndex.add(word.name, word.id!);
    defIndex.add(word.def, word.id!);
  }

  /// Add items
  static Future<void> addAll(Iterable<Word> words) async {
    // empty ids so that it will be generated by isar
    for (Word word in words) {
      word.id = null;
    }

    // add
    await Database.isar.writeTxn((isar) async {
      await Database.isar.words.putAll(words.toList());
    });

    // update indexes
    for (Word word in words) {
      nameIndex.add(word.name, word.id!);
      defIndex.add(word.def, word.id!);
    }
  }

  /// Save an item associated with id
  static Future<void> put(Word word) async {
    assert(word.id != null);
    await Database.isar.writeTxn((isar) async {
      await isar.words.put(word);
    });

    // update indexes
    nameIndex.removeByValue(word.id!);
    defIndex.removeByValue(word.id!);
    nameIndex.add(word.name, word.id!);
    defIndex.add(word.def, word.id!);
  }

  /// Delete an item
  static Future<void> delete(int id) async {
    await Database.isar.writeTxn((isar) async {
      await isar.words.delete(id);
    });

    // update indexes
    nameIndex.removeByValue(id);
    defIndex.removeByValue(id);
  }

  /// Delete items by [ids]
  static Future<void> deletes(Iterable<int> ids) async {
    await Database.isar.writeTxn((isar) async {
      await isar.words.deleteAll(ids.toList());
    });

    // update indexes
    for (int id in ids) {
      nameIndex.removeByValue(id);
      defIndex.removeByValue(id);
    }
  }

  /// Delete all items
  static Future<void> deleteAll() async {
    await Database.isar.writeTxn((isar) async {
      await isar.words.where().deleteAll();
    });

    // update indexes
    nameIndex.clear();
    defIndex.clear();
  }

  /// RETURN: the number of all items
  static Future<int> count() {
    return Database.isar.words.where().count();
  }

  /// Get stream
  static Stream<void> getStream() {
    return Database.isar.words.watchLazy();
  }

  //---------------------------------------------------------------//
  //        internal methods
  //---------------------------------------------------------------//

  // generate a random sync id
  static String _createRandomSyncId() {
    var uuid = const Uuid();
    return uuid.v4();
  }
}
